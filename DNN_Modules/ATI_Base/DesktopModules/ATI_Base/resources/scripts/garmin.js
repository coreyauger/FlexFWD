
/**
* Copyright Â© 2007 Garmin Ltd. or its subsidiaries.
*
* Licensed under the Apache License, Version 2.0 (the 'License')
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
* @fileoverview Garmin.Broadcaster is for registering listeners and dispatching call-back metheds.
* 
* @author Jason Holmes jason.holmes.at.garmin.com
* @version 1.0
*/
/**
http://developer.garmin.com/web/communicator-api/garmin/util/Util-Broadcaster.js
http://developer.garmin.com/web/communicator-api/garmin/util/Util-BrowserDetect.js
http://developer.garmin.com/web/communicator-api/garmin/util/Util-DateTimeFormat.js
http://developer.garmin.com/web/communicator-api/garmin/util/Util-PluginDetect.js
http://developer.garmin.com/web/communicator-api/garmin/util/Util-XmlConverter.js

http://developer.garmin.com/web/communicator-api/garmin/device/GarminObjectGenerator.js
http://developer.garmin.com/web/communicator-api/garmin/device/GarminPluginUtils.js
http://developer.garmin.com/web/communicator-api/garmin/device/GarminDevice.js
http://developer.garmin.com/web/communicator-api/garmin/device/GarminDevicePlugin.js
http://developer.garmin.com/web/communicator-api/garmin/device/GarminDeviceControl.js
*/

if (Garmin == undefined) var Garmin = {}; Garmin.Broadcaster = function () { }; Garmin.Broadcaster = Class.create(); Garmin.Broadcaster.prototype = { initialize: function () { this.responders = new Array() }, register: function (responderToAdd) { if (!this.responders.include(responderToAdd)) this.responders.push(responderToAdd) }, unregister: function (responderToRemove) { this.responders = this.responders.without(responderToRemove) }, dispatch: function (callback, json) { this.responders.each(function (responder) { if (responder[callback] && typeof responder[callback] == 'function') { try { responder[callback].apply(responder, [json]) } catch (e) { alert(e) } } }) } };
if (Garmin == undefined) var Garmin = {}; var BrowserDetect = { init: function () { this.browser = this.searchString(this.dataBrowser) || "An unknown browser"; this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version"; this.OS = this.searchString(this.dataOS) || "an unknown OS" }, searchString: function (data) { for (var i = 0; i < data.length; i++) { var dataString = data[i].string; var dataProp = data[i].prop; this.versionSearchString = data[i].versionSearch || data[i].identity; if (dataString) { if (dataString.indexOf(data[i].subString) != -1) return data[i].identity } else if (dataProp) return data[i].identity } }, searchVersion: function (dataString) { var index = dataString.indexOf(this.versionSearchString); if (index == -1) return; return parseFloat(dataString.substring(index + this.versionSearchString.length + 1)) }, dataBrowser: [{ string: navigator.userAgent, subString: "OmniWeb", versionSearch: "OmniWeb/", identity: "OmniWeb" }, { string: navigator.vendor, subString: "Apple", identity: "Safari" }, { prop: window.opera, identity: "Opera" }, { string: navigator.vendor, subString: "iCab", identity: "iCab" }, { string: navigator.vendor, subString: "KDE", identity: "Konqueror" }, { string: navigator.userAgent, subString: "Firefox", identity: "Firefox" }, { string: navigator.vendor, subString: "Camino", identity: "Camino" }, { string: navigator.userAgent, subString: "Netscape", identity: "Netscape" }, { string: navigator.userAgent, subString: "MSIE", identity: "Explorer", versionSearch: "MSIE" }, { string: navigator.userAgent, subString: "Gecko", identity: "Mozilla", versionSearch: "rv" }, { string: navigator.userAgent, subString: "Mozilla", identity: "Netscape", versionSearch: "Mozilla"}], dataOS: [{ string: navigator.platform, subString: "Win", identity: "Windows" }, { string: navigator.platform, subString: "Mac", identity: "Mac" }, { string: navigator.platform, subString: "Linux", identity: "Linux"}] }; BrowserDetect.init();
if (Garmin == undefined) var Garmin = {}; Garmin.DateTimeFormat = function () { }; Garmin.DateTimeFormat = Class.create(); Garmin.DateTimeFormat.prototype = { initialize: function () { this.hoursInADay = 24; this.minutesInAnHour = 60; this.secondsInAMinute = 60; this.millisecondsInASecond = 1000; this.millisecondsInADay = this.hoursInADay * this.minutesInAnHour * this.secondsInAMinute * this.millisecondsInASecond; this.millisecondsInAnHour = this.minutesInAnHour * this.secondsInAMinute * this.millisecondsInASecond; this.millisecondsInAMinute = this.secondsInAMinute * this.millisecondsInASecond; this.xsdString = ""; this.date = new Date() }, getDate: function () { return this.date }, parseXsdDateTime: function (xsdDateTime) { this.xsdString = xsdDateTime; var pieces = xsdDateTime.split('T'); var datePiece = pieces[0]; var timePiece = pieces[1]; var offset = 0; var datePieces = datePiece.split('-'); var year = parseInt(datePieces[0], 10); var month = parseInt(datePieces[1], 10) - 1; var dayOfMonth = parseInt(datePieces[2], 10); var offsetIndex; if (timePiece.indexOf('Z') != -1) { offsetIndex = timePiece.indexOf('Z') } else if (timePiece.indexOf('+') != -1) { offsetIndex = timePiece.indexOf('+') } else if (timePiece.indexOf('-') != -1) { offsetIndex = timePiece.indexOf('-') } else { offsetIndex = timePiece.length } var offsetPieces = timePiece.substring(offsetIndex).split(':'); var offsetHour = 0; var offsetMinute = 0; if (offsetPieces.length > 1) { offsetHour = parseInt(offsetPieces[0], 10); offsetMinute = parseInt(offsetPieces[1], 10) } var offsetMilliseconds = ((((offsetHour * 60) + offsetMinute) * 60) * 1000); var timePieces = timePiece.substring(0, offsetIndex).split(':'); var hourBase24 = parseInt(timePieces[0], 10); var minute = parseInt(timePieces[1], 10); var secondPieces = timePieces[2].split('.'); var second = parseInt(secondPieces[0], 10); var millisecond = 0; if (secondPieces.length > 1) { millisecond = parseInt(secondPieces[1], 10) } var date = new Date(); date.setUTCFullYear(year); date.setUTCMonth(month); date.setUTCDate(dayOfMonth); date.setUTCHours(hourBase24); date.setUTCMinutes(minute); date.setUTCSeconds(second); date.setUTCMilliseconds(millisecond); date.setTime(date.getTime() - offsetMilliseconds); this.date = date; return this }, formatDuration: function (milliseconds) { var remaining = milliseconds; var result = ""; var separator = ':'; var units = new Array(this.millisecondsInADay, this.millisecondsInAnHour, this.millisecondsInAMinute, this.millisecondsInASecond); for (var whichUnit = 0; whichUnit < units.length; whichUnit++) { var millisecondsInUnit = units[whichUnit]; var totalOfUnit = parseInt(remaining / millisecondsInUnit); if (whichUnit != 0 || totalOfUnit != 0) { if (totalOfUnit < 10) result += "0"; result = result + totalOfUnit.toString(); if (whichUnit < units.length - 1) result += separator } remaining = remaining - (totalOfUnit * millisecondsInUnit) } return result }, getDurationTo: function (endDateTime) { return this.formatDuration(endDateTime.getDate().getTime() - this.getDate().getTime()) }, getDayOfYear: function () { with (this.getDate()) { var Y = getFullYear(), M = getMonth(), D = getDate() } var K, N; N = (Date.UTC(Y, M, D) - Date.UTC(Y, 0, 0)) / 86400000; M++; K = 2 - (Y % 4 == 0); N = Math.floor(275 * M / 9) - K * (M > 2) + D - 30; with (this.getDate()) { K = valueOf(); setMonth(0); setDate(0); N = Math.round((K - valueOf()) / 86400000) } return N }, getDateString: function () { return this.formatDate(true) }, getTimeString: function () { return this.format(Garmin.DateTimeFormat.FORMAT.timestamp12hour, true, true) }, getXsdString: function () { return this.xsdString }, toString: function () { return this.date.toString() }, formatDate: function (leftPad) { return this.format(Garmin.DateTimeFormat.FORMAT.date, leftPad) }, formatTime: function (leftPad) { return this.format(Garmin.DateTimeFormat.FORMAT.time, leftPad) }, formatTimestamp: function (leftPad) { return this.format(Garmin.DateTimeFormat.FORMAT.timestamp, leftPad) }, format: function (template, leftPad, twelveHourClock) { if (leftPad != false) leftPad = true; var hours = this.date.getHours(); var values = { meridian: this.date.getHours() >= 12 ? "PM" : "AM", month: this.leftPad(this.date.getMonth() + 1, leftPad), day: this.leftPad(this.date.getDate(), leftPad), year: this.date.getFullYear(), hour: this.leftPad((twelveHourClock && hours > 12) ? hours - 12 : hours, leftPad), minute: this.leftPad(this.date.getMinutes(), leftPad), second: this.leftPad(this.date.getSeconds(), leftPad), millisecond: this.date.getMilliseconds(), timezone: this.date.getTimezoneOffset() / 60 }; return new Template(template).evaluate(values) }, leftPad: function (integer, activate) { return (activate && integer < 10) ? "0" + integer : "" + integer } }; Garmin.DateTimeFormat.FORMAT = { date: "#{month}/#{day}/#{year}", time: "#{hour}:#{minute}:#{second}", timestamp: "#{month}/#{day}/#{year} #{hour}:#{minute}:#{second}", timestamp12hour: "#{month}/#{day}/#{year} #{hour}:#{minute}:#{second} #{meridian}" };
if (Garmin == undefined) var Garmin = {}; var detectableWithVB = false; var PluginDetect = { init: function () { if ((navigator.userAgent.indexOf('MSIE') != -1) && (navigator.userAgent.indexOf('Win') != -1)) { document.writeln('<script language="VBscript">'); document.writeln('\'do a one-time test for a version of VBScript that can handle this code'); document.writeln('detectableWithVB = False'); document.writeln('If ScriptEngineMajorVersion >= 2 then'); document.writeln('  detectableWithVB = True'); document.writeln('End If'); document.writeln('\'this next function will detect most plugins'); document.writeln('Function detectActiveXControl(activeXControlName)'); document.writeln('  on error resume next'); document.writeln('  detectActiveXControl = False'); document.writeln('  If detectableWithVB Then'); document.writeln('     detectActiveXControl = IsObject(CreateObject(activeXControlName))'); document.writeln('  End If'); document.writeln('End Function'); document.writeln('</script>') } }, canDetectPlugins: function () { if (detectableWithVB || (navigator.plugins && navigator.plugins.length > 0)) { return true } else { return false } }, detectFlash: function () { var pluginFound = PluginDetect.detectPlugin('Shockwave', 'Flash'); if (!pluginFound && detectableWithVB) { pluginFound = detectActiveXControl('ShockwaveFlash.ShockwaveFlash.1') } return pluginFound }, detectGarminCommunicatorPlugin: function () { var pluginFound = PluginDetect.detectPlugin('Garmin Communicator'); if (!pluginFound && detectableWithVB) { pluginFound = detectActiveXControl('GARMINAXCONTROL.GarminAxControl_t.1') } return pluginFound }, detectPlugin: function () { var daPlugins = PluginDetect.detectPlugin.arguments; var pluginFound = false; if (navigator.plugins && navigator.plugins.length > 0) { var pluginsArrayLength = navigator.plugins.length; for (pluginsArrayCounter = 0; pluginsArrayCounter < pluginsArrayLength; pluginsArrayCounter++) { var numFound = 0; for (namesCounter = 0; namesCounter < daPlugins.length; namesCounter++) { if ((navigator.plugins[pluginsArrayCounter].name.indexOf(daPlugins[namesCounter]) >= 0) || (navigator.plugins[pluginsArrayCounter].description.indexOf(daPlugins[namesCounter]) >= 0)) { numFound++ } } if (numFound == daPlugins.length) { pluginFound = true; break } } } return pluginFound } }; PluginDetect.init();
if (Garmin == undefined) var Garmin = {}; Garmin.XmlConverter = function () { }; Garmin.XmlConverter = { toDocument: function (fromString) { return Try.these(function () { var theDocument = new ActiveXObject("Microsoft.XMLDOM"); theDocument.async = "false"; theDocument.loadXML(fromString); return theDocument }, function () { return new DOMParser().parseFromString(fromString, "text/xml") }) }, toString: function (fromDocument) { if (window.ActiveXObject) { return fromDocument.xml } else { var theXmlSerializer = new XMLSerializer(); return theXmlSerializer.serializeToString(fromDocument) } } };
if (PluginDetect.detectGarminCommunicatorPlugin()) { switch (BrowserDetect.browser) { case "Explorer": document.write('<object id="GarminActiveXControl" style="WIDTH: 0px; HEIGHT: 0px; visible: hidden" height="0" width="0" classid="CLSID:099B5A62-DE20-48C6-BF9E-290A9D1D8CB5">&#160;</object>'); break; case "Firefox": case "Mozilla": case "Safari": document.write('<div style="height:0px; width:0px;">'); document.write('<object id="GarminNetscapePlugin" type="application/vnd-garmin.mygarmin" width="0" height="0">&#160;</object>'); document.write('</div>'); break; default: document.write('<div style="height:0px; width:0px;"><object id="GarminActiveXControl" style="WIDTH: 0px; HEIGHT: 0px; visible: hidden" height="0" width="0" classid="CLSID:099B5A62-DE20-48C6-BF9E-290A9D1D8CB5">'); document.write('	<object id="GarminNetscapePlugin" type="application/vnd-garmin.mygarmin" width="0" height="0">&#160;</object>'); document.write('</object></div>'); break } }
if (Garmin == undefined) var Garmin = {}; Garmin.PluginUtils = function () { }; Garmin.PluginUtils = { initialize: function () { }, parseDeviceXml: function (garminPlugin, getDetailedDeviceData) { var xmlDevicesString = garminPlugin.getDevicesXml(); var xmlDevicesDoc = Garmin.XmlConverter.toDocument(xmlDevicesString); var deviceList = xmlDevicesDoc.getElementsByTagName("Device"); var devices = new Array(); var numDevices = deviceList.length; for (var i = 0; i < numDevices; i++) { var displayName = deviceList[i].getAttribute("DisplayName"); var deviceNumber = parseInt(deviceList[i].getAttribute("Number")); var deviceDescriptionDoc = null; if (getDetailedDeviceData) { var deviceDescriptionXml = garminPlugin.getDeviceDescriptionXml(deviceNumber); deviceDescriptionDoc = Garmin.XmlConverter.toDocument(deviceDescriptionXml) } devices.push(Garmin.PluginUtils._createDeviceFromXml(displayName, deviceNumber, deviceDescriptionDoc)) } return devices }, _createDeviceFromXml: function (displayName, deviceNumber, deviceDescriptionDoc) { var device = new Garmin.Device(displayName, deviceNumber); if (deviceDescriptionDoc) { var partNumber = deviceDescriptionDoc.getElementsByTagName("PartNumber")[0].childNodes[0].nodeValue; var softwareVersion = deviceDescriptionDoc.getElementsByTagName("SoftwareVersion")[0].childNodes[0].nodeValue; var description = deviceDescriptionDoc.getElementsByTagName("Description")[0].childNodes[0].nodeValue; var id = deviceDescriptionDoc.getElementsByTagName("Id")[0].childNodes[0].nodeValue; device.setPartNumber(partNumber); device.setSoftwareVersion(softwareVersion); device.setDescription(description); device.setId(id); var dataTypeList = deviceDescriptionDoc.getElementsByTagName("MassStorageMode")[0].getElementsByTagName("DataType"); var numOfDataTypes = dataTypeList.length; for (var j = 0; j < numOfDataTypes; j++) { var dataName = dataTypeList[j].getElementsByTagName("Name")[0].childNodes[0].nodeValue; var dataExt = dataTypeList[j].getElementsByTagName("FileExtension")[0].childNodes[0].nodeValue; var dataType = new Garmin.DeviceDataType(dataName, dataExt); var fileList = dataTypeList[j].getElementsByTagName("File"); var numOfFiles = fileList.length; for (var k = 0; k < numOfFiles; k++) { var pathList = fileList[k].getElementsByTagName("Path"); var transferDir = fileList[k].getElementsByTagName("TransferDirection")[0].childNodes[0].nodeValue; if ((transferDir == Garmin.DeviceControl.TRANSFER_DIRECTIONS.read)) { dataType.setReadAccess(true); if (pathList.length > 0) { var filePath = pathList[0].childNodes[0].nodeValue; dataType.setReadFilePath(filePath) } } else if ((transferDir == Garmin.DeviceControl.TRANSFER_DIRECTIONS.write)) { dataType.setWriteAccess(true); if (pathList.length > 0) { var filePath = pathList[0].childNodes[0].nodeValue; dataType.setWriteFilePath(filePath) } } else if ((transferDir == Garmin.DeviceControl.TRANSFER_DIRECTIONS.both)) { dataType.setReadAccess(true); dataType.setWriteAccess(true); if (pathList.length > 0) { var filePath = pathList[0].childNodes[0].nodeValue; dataType.setReadFilePath(filePath); dataType.setWriteFilePath(filePath) } } if (pathList.length > 0) { var filePath = pathList[0].childNodes[0].nodeValue; dataType.setFilePath(filePath) } var identifierList = fileList[k].getElementsByTagName("Identifier"); if (identifierList.length > 0) { var identifier = identifierList[0].childNodes[0].nodeValue; dataType.setIdentifier(identifier) } } device.addDeviceDataType(dataType) } } return device }, isDeviceErrorXml: function (error) { var msg = (typeof (error) == "string") ? error : error.name + ": " + error.message; return ((msg.indexOf("<ErrorReport") > 0)) }, getDeviceErrorMessage: function (error) { var msg = (typeof (error) == "string") ? error : error.name + ": " + error.message; var startPos = msg.indexOf("<ErrorReport"); if (startPos > 0) { var endPos = msg.indexOf("</ErrorReport>") + "</ErrorReport>".length; msg = msg.substring(startPos, endPos) } var xmlDoc = Garmin.XmlConverter.toDocument(msg); var errorMessage = Garmin.PluginUtils._getElementValue(xmlDoc, "Extra"); var sourceFileName = Garmin.PluginUtils._getElementValue(xmlDoc, "SourceFileName"); var sourceFileLine = Garmin.PluginUtils._getElementValue(xmlDoc, "SourceFileLine"); var msg = ""; if (errorMessage) { msg = errorMessage } else { msg = "Plugin error: "; if (sourceFileName) msg += "source: " + sourceFileName; if (sourceFileLine) msg += ", line: " + sourceFileLine } return msg }, _getElementValue: function (doc, elementName) { var elementNameNodes = doc.getElementsByTagName(elementName); var value = (elementNameNodes && elementNameNodes.length > 0) ? elementNameNodes[0].childNodes[0].nodeValue : null; return value } }; Garmin.GpiUtil = function () { }; Garmin.GpiUtil = { buildMultipleDeviceDownloadsXML: function (descriptionArray) { if (descriptionArray.length % 2 != 0) { throw new Error("buildMultipleDeviceDownloadsXML expects even sized array with matching source and destination pairs") } var xml = '<?xml version="1.0" encoding="UTF-8"?>\n' + '<DeviceDownload xmlns="http://www.garmin.com/xmlschemas/PluginAPI/v1"\n' + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n' + ' xsi:schemaLocation="http://www.garmin.com/xmlschemas/PluginAPI/v1 http://www.garmin.com/xmlschemas/GarminPluginAPIV1.xsd">\n'; for (var i = 0; i < descriptionArray.length; i += 2) { var source = descriptionArray[i]; var destination = descriptionArray[i + 1]; xml += ' <File Source="' + source + '" Destination="' + destination + '" RegionId="46" />\n' } xml += '</DeviceDownload>'; return xml }, buildDeviceDownloadXML: function (source, destination) { return Garmin.GpiUtil.buildMultipleDeviceDownloadsXML([source, destination]) }, isDestinationValid: function (destination) { var splitPath = destination.split("/"); var filename = splitPath[splitPath.length - 1]; var lengthBefore = filename.length; var stringAfter = Garmin.GpiUtil.cleanUpFilename(filename); return (lengthBefore == stringAfter.length) }, cleanUpFilename: function (filename) { var result = filename; var replacement = ""; result = result.stripTags(); result = result.replace(/&amp;/, replacement); result = result.replace(/[\x21-\x2F]/g, replacement); result = result.replace(/[\x5B-\x60]/g, replacement); result = result.replace(/[\x3A-\x40]/g, replacement); result = result.strip(); return result } };
if (Garmin == undefined) var Garmin = {}; Garmin.Device = function (displayName, number) { }; Garmin.Device = Class.create(); Garmin.Device.prototype = { initialize: function (displayName, number) { this.displayName = displayName; this.number = number; this.partNumber = null; this.softwareVersion = null; this.description = null; this.id = null; this.dataTypes = new Hash({}) }, getDisplayName: function () { return this.displayName }, getNumber: function () { return this.number }, setPartNumber: function (partNumber) { this.partNumber = partNumber }, getPartNumber: function () { return this.partNumber }, setSoftwareVersion: function (softwareVersion) { this.softwareVersion = softwareVersion }, getSoftwareVersion: function () { return this.softwareVersion }, setDescription: function (description) { this.description = description }, getDescription: function () { return this.description }, setId: function (id) { this.id = id }, getId: function () { return this.id }, addDeviceDataType: function (dataType) { var newDataType = new Hash(); newDataType.set(dataType.getTypeName(), dataType); this.dataTypes.update(newDataType) }, getDeviceDataType: function (extension) { return this.dataTypes.get(extension) }, getDeviceDataTypes: function () { return this.dataTypes }, supportDeviceDataTypeRead: function (extension) { var dataType = this.getDeviceDataType(extension); if (dataType != null && dataType.hasReadAccess()) { return true } else { return false } }, supportDeviceDataTypeWrite: function (extension) { var dataType = this.getDeviceDataType(extension); if (dataType != null && dataType.hasWriteAccess()) { return true } else { return false } }, toString: function () { return "Device[" + this.getDisplayName() + ", " + this.getDescription() + ", " + this.getNumber() + "]" } }; Garmin.DeviceDataType = function (typeName, fileExtension) { }; Garmin.DeviceDataType = Class.create(); Garmin.DeviceDataType.prototype = { initialize: function (typeName, fileExtension) { this.typeName = typeName; this.fileExtension = fileExtension; this.readAccess = false; this.writeAccess = false; this.filePath = null; this.readFilePath = null; this.writeFilePath = null; this.identifier = null }, getTypeName: function () { return this.typeName }, getDisplayName: function () { return this.getTypeName() }, getFileExtension: function () { return this.fileExtension }, getFilePath: function () { return this.filePath }, setFilePath: function (filePath) { this.filePath = filePath }, getReadFilePath: function () { return this.readFilePath }, setReadFilePath: function (readFilePath) { this.readFilePath = readFilePath }, getWriteFilePath: function () { return this.writeFilePath }, setWriteFilePath: function (writeFilePath) { this.writeFilePath = writeFilePath }, getIdentifier: function () { return this.identifier }, setIdentifier: function (identifier) { this.identifier = identifier }, setReadAccess: function (readAccess) { this.readAccess = readAccess }, hasReadAccess: function () { return this.readAccess }, setWriteAccess: function (writeAccess) { this.writeAccess = writeAccess }, hasWriteAccess: function () { return this.writeAccess } };
if (Garmin == undefined) var Garmin = {}; Garmin.DevicePlugin = function (pluginElement) { }; Garmin.DevicePlugin = Class.create(); Garmin.DevicePlugin.prototype = { initialize: function (pluginElement) { this.plugin = pluginElement; this.unlocked = false }, unlock: function (pathKeyPairsArray) { var len = pathKeyPairsArray ? pathKeyPairsArray.length / 2 : 0; for (var i = 0; i < len; i++) { if (this.plugin.Unlock(pathKeyPairsArray[i * 2], pathKeyPairsArray[i * 2 + 1])) { this.unlocked = true; return this.unlocked } } this.tryUnlock = this.plugin.Unlock("file:///", "cb1492ae040612408d87cc53e3f7ff3c") || this.plugin.Unlock("http://localhost", "45517b532362fc3149e4211ade14c9b2") || this.plugin.Unlock("http://127.0.0.1", "40cd4860f7988c53b15b8491693de133"); this.unlocked = !this.plugin.Locked; return this.unlocked }, isUnlocked: function () { return this.unlocked }, _getPluginFunctionExists: function (pluginFunctionName) { var pluginFunction = "this.plugin." + pluginFunctionName; try { if (typeof eval(pluginFunction) == "function") { return true } else if (eval(pluginFunction)) { return true } else { return false } } catch (e) { return true } }, _getPluginFieldExists: function (pluginField) { try { if (typeof pluginField == "string") { return true } else if (pluginField) { return true } else { return false } } catch (e) { return true } }, getSupportsFitnessWrite: function () { return this._getPluginFunctionExists("StartWriteFitnessData") }, getSupportsFitnessDirectoryRead: function () { return this._getPluginFunctionExists("StartReadFitnessDirectory") }, getSupportsFitDirectoryRead: function () { return this._getPluginFunctionExists("StartReadFITDirectory") }, getSupportsFitnessReadCompressed: function () { return this._getPluginFieldExists(this.plugin.TcdXmlz) }, startFindDevices: function () { this.plugin.StartFindDevices() }, cancelFindDevices: function () { this.plugin.CancelFindDevices() }, finishFindDevices: function () { return this.plugin.FinishFindDevices() }, getDevicesXml: function () { return this.plugin.DevicesXmlString() }, getDeviceDescriptionXml: function (deviceNumber) { return this.plugin.DeviceDescription(deviceNumber) }, startReadFromGps: function (deviceNumber) { this.plugin.StartReadFromGps(deviceNumber) }, finishReadFromGps: function () { return this.plugin.FinishReadFromGps() }, cancelReadFromGps: function () { this.plugin.CancelReadFromGps() }, startReadFitnessData: function (deviceNumber, dataTypeName) { if (!this.checkPluginVersionSupport([2, 1, 0, 3])) { throw new Error("Your Communicator Plug-in version (" + this.getPluginVersionString() + ") does not support reading this type of fitness data.") } this.plugin.StartReadFitnessData(deviceNumber, dataTypeName) }, finishReadFitnessData: function () { return this.plugin.FinishReadFitnessData() }, cancelReadFitnessData: function () { this.plugin.CancelReadFitnessData() }, startReadFitDirectory: function (deviceNumber) { if (!this.getSupportsFitDirectoryRead()) { throw new Error("Your Communicator Plug-in version (" + this.getPluginVersionString() + ") does not support reading directory listing data.") } this.plugin.StartReadFITDirectory(deviceNumber) }, finishReadFitDirectory: function () { return this.plugin.FinishReadFITDirectory() }, startReadFitnessDirectory: function (deviceNumber, dataTypeName) { if (!this.getSupportsFitnessDirectoryRead()) { throw new Error("Your Communicator Plug-in version (" + this.getPluginVersionString() + ") does not support reading fitness directory data.") } this.plugin.StartReadFitnessDirectory(deviceNumber, dataTypeName) }, finishReadFitnessDirectory: function () { return this.plugin.FinishReadFitnessDirectory() }, cancelReadFitnessDirectory: function () { this.plugin.CancelReadFitnessDirectory() }, cancelReadFitDirectory: function () { this.plugin.CancelReadFitDirectory() }, startReadFitnessDetail: function (deviceNumber, dataTypeName, dataId) { if (!this.checkPluginVersionSupport([2, 2, 0, 2])) { throw new Error("Your Communicator Plug-in version (" + this.getPluginVersionString() + ") does not support reading fitness detail.") } this.plugin.StartReadFitnessDetail(deviceNumber, dataTypeName, dataId) }, finishReadFitnessDetail: function () { return this.plugin.FinishReadFitnessDetail() }, cancelReadFitnessDetail: function () { this.plugin.CancelReadFitnessDetail() }, startWriteToGps: function (gpsXml, filename, deviceNumber) { this._setWriteGpsXml(gpsXml); this._setWriteFilename(filename); this.plugin.StartWriteToGps(deviceNumber) }, _setWriteGpsXml: function (gpsXml) { this.plugin.GpsXml = gpsXml }, _setWriteFilename: function (filename) { this.plugin.FileName = filename }, finishWriteToGps: function () { return this.plugin.FinishWriteToGps() }, cancelWriteToGps: function () { this.plugin.CancelWriteToGps() }, startWriteFitnessData: function (tcdXml, deviceNumber, filename, dataTypeName) { if (!this.checkPluginVersionSupport([2, 2, 0, 1])) { throw new Error("Your Communicator Plug-in version (" + this.getPluginVersionString() + ") does not support writing fitness data.") } this._setWriteTcdXml(tcdXml); this._setWriteFilename(filename); this.plugin.StartWriteFitnessData(deviceNumber, dataTypeName) }, finishWriteFitnessData: function () { return this.plugin.FinishWriteFitnessData() }, cancelWriteFitnessData: function () { this.plugin.CancelWriteFitnessData() }, _setWriteTcdXml: function (tcdXml) { this.plugin.TcdXml = tcdXml }, bytesAvailable: function (deviceNumber, relativeFilePath) { return this.plugin.BytesAvailable(deviceNumber, relativeFilePath) }, respondToMessageBox: function (response) { this.plugin.RespondToMessageBox(response) }, startDownloadData: function (gpsDataString, deviceNumber) { this.plugin.StartDownloadData(gpsDataString, deviceNumber) }, finishDownloadData: function () { return this.plugin.FinishDownloadData() }, cancelDownloadData: function () { this.plugin.CancelDownloadData() }, downloadDataSucceeded: function () { return this.plugin.DownloadDataSucceeded }, startUnitSoftwareUpdate: function (updateResponsesXml, deviceNumber) { this.plugin.StartUnitSoftwareUpdate(updateResponsesXml, deviceNumber) }, finishUnitSoftwareUpdate: function () { return this.plugin.FinishUnitSoftwareUpdate() }, cancelUnitSoftwareUpdate: function () { this.plugin.CancelUnitSoftwareUpdate() }, gpsTransferSucceeded: function () { return this.plugin.GpsTransferSucceeded }, fitnessTransferSucceeded: function () { return this.plugin.FitnessTransferSucceeded }, getBinaryFile: function (deviceNumber, relativeFilePath, compressed) { return this.plugin.GetBinaryFile(deviceNumber, relativeFilePath, compressed) }, getGpsXml: function () { return this.plugin.GpsXml }, getTcdXml: function () { return this.plugin.TcdXml }, getTcdXmlz: function () { return this.plugin.TcdXmlz }, getDirectoryXml: function () { return this.plugin.DirectoryListingXml }, getMessageBoxXml: function () { return this.plugin.MessageBoxXml }, getProgressXml: function () { return this.plugin.ProgressXml }, getVersionXml: function () { return this.plugin.VersionXml }, getPluginVersionString: function () { var versionArray = this.getPluginVersion(); var versionString = versionArray[0] + "." + versionArray[1] + "." + versionArray[2] + "." + versionArray[3]; return versionString }, getPluginVersion: function () { var versionMajor = parseInt(this._getElementValue(this.getVersionXml(), "VersionMajor")); var versionMinor = parseInt(this._getElementValue(this.getVersionXml(), "VersionMinor")); var buildMajor = parseInt(this._getElementValue(this.getVersionXml(), "BuildMajor")); var buildMinor = parseInt(this._getElementValue(this.getVersionXml(), "BuildMinor")); var versionArray = [versionMajor, versionMinor, buildMajor, buildMinor]; return versionArray }, setPluginRequiredVersion: function (reqVersionArray) { Garmin.DevicePlugin.REQUIRED_VERSION.versionMajor = reqVersionArray[0]; Garmin.DevicePlugin.REQUIRED_VERSION.versionMinor = reqVersionArray[1]; Garmin.DevicePlugin.REQUIRED_VERSION.buildMajor = reqVersionArray[2]; Garmin.DevicePlugin.REQUIRED_VERSION.buildMinor = reqVersionArray[3] }, setPluginLatestVersion: function (reqVersionArray) { Garmin.DevicePlugin.LATEST_VERSION.versionMajor = reqVersionArray[0]; Garmin.DevicePlugin.LATEST_VERSION.versionMinor = reqVersionArray[1]; Garmin.DevicePlugin.LATEST_VERSION.buildMajor = reqVersionArray[2]; Garmin.DevicePlugin.LATEST_VERSION.buildMinor = reqVersionArray[3] }, checkPluginVersionSupport: function (reqVersionArray) { var pVersion = this._versionToNumber(this.getPluginVersion()); var rVersion = this._versionToNumber(reqVersionArray); return (pVersion >= rVersion) }, _versionToNumber: function (versionArray) { if (versionArray[1] > 99 || versionArray[2] > 99 || versionArray[3] > 99) throw new Error("version segment is greater than 99: " + versionArray); return 1000000 * versionArray[0] + 10000 * versionArray[1] + 100 * versionArray[2] + versionArray[3] }, isPluginOutOfDate: function () { var pVersion = this._versionToNumber(this.getPluginVersion()); var rVersion = this._versionToNumber(Garmin.DevicePlugin.REQUIRED_VERSION.toArray()); return (pVersion < rVersion) }, isUpdateAvailable: function () { var pVersion = this._versionToNumber(this.getPluginVersion()); var cVersion = this._versionToNumber(Garmin.DevicePlugin.LATEST_VERSION.toArray()); return (pVersion < cVersion) }, _getElementValue: function (xml, tagName) { var start = xml.indexOf("<" + tagName + ">"); if (start == -1) return null; start += tagName.length + 2; var end = xml.indexOf("</" + tagName + ">"); var result = xml.substring(start, end); return result } }; Garmin.DevicePlugin.LATEST_VERSION = { versionMajor: 2, versionMinor: 7, buildMajor: 3, buildMinor: 0, toString: function () { return this.versionMajor + "." + this.versionMinor + "." + this.buildMajor + "." + this.buildMinor }, toArray: function () { return [this.versionMajor, this.versionMinor, this.buildMajor, this.buildMinor] } }; Garmin.DevicePlugin.REQUIRED_VERSION = { versionMajor: 2, versionMinor: 1, buildMajor: 0, buildMinor: 1, toString: function () { return this.versionMajor + "." + this.versionMinor + "." + this.buildMajor + "." + this.buildMinor }, toArray: function () { return [this.versionMajor, this.versionMinor, this.buildMajor, this.buildMinor] } };
if (Garmin == undefined) var Garmin = {}; Garmin.DeviceControl = function () { }; Garmin.DeviceControl = Class.create(); Garmin.DeviceControl.prototype = { initialize: function () { this.pluginUnlocked = false; try { if (typeof (Garmin.DevicePlugin) == 'undefined') throw '' } catch (e) { throw new Error(Garmin.DeviceControl.MESSAGES.deviceControlMissing) }; if (!BrowserSupport.isBrowserSupported()) { var notSupported = new Error(Garmin.DeviceControl.MESSAGES.browserNotSupported); notSupported.name = "BrowserNotSupportedException"; throw notSupported } if (!PluginDetect.detectGarminCommunicatorPlugin()) { var notInstalled = new Error(Garmin.DeviceControl.MESSAGES.pluginNotInstalled); notInstalled.name = "PluginNotInstalledException"; throw notInstalled } var pluginElement; if (window.ActiveXObject) { pluginElement = $("GarminActiveXControl") } else { pluginElement = $("GarminNetscapePlugin") } if (pluginElement == null) { var error = new Error(Garmin.DeviceControl.MESSAGES.missingPluginTag); error.name = "HtmlTagNotFoundException"; throw error } this.garminPlugin = new Garmin.DevicePlugin(pluginElement); this.validatePlugin(); this._broadcaster = new Garmin.Broadcaster(); this.getDetailedDeviceData = true; this.devices = new Array(); this.deviceNumber = null; this.numDevices = 0; this.gpsData = null; this.gpsDataType = null; this.gpsDataString = ""; this.gpsDataStringCompressed = "" }, validatePlugin: function () { if (!this.isPluginInstalled()) { var notInstalled = new Error(Garmin.DeviceControl.MESSAGES.pluginNotInstalled); notInstalled.name = "PluginNotInstalledException"; throw notInstalled } if (this.garminPlugin.isPluginOutOfDate()) { var outOfDate = new Error(Garmin.DeviceControl.MESSAGES.outOfDatePlugin1 + Garmin.DevicePlugin.REQUIRED_VERSION.toString() + Garmin.DeviceControl.MESSAGES.outOfDatePlugin2 + this.getPluginVersionString()); outOfDate.name = "OutOfDatePluginException"; outOfDate.version = this.getPluginVersionString(); throw outOfDate } }, checkForUpdates: function () { if (this.garminPlugin.isUpdateAvailable()) { var notLatest = new Error(Garmin.DeviceControl.MESSAGES.updatePlugin1 + Garmin.DevicePlugin.LATEST_VERSION.toString() + Garmin.DeviceControl.MESSAGES.updatePlugin2 + this.getPluginVersionString()); notLatest.name = "UpdatePluginException"; notLatest.version = this.getPluginVersionString(); throw notLatest } }, findDevices: function () { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); this.garminPlugin.startFindDevices(); this._broadcaster.dispatch("onStartFindDevices", { controller: this }); setTimeout(function () { this._finishFindDevices() } .bind(this), 1000) }, cancelFindDevices: function () { this.garminPlugin.cancelFindDevices(); this._broadcaster.dispatch("onCancelFindDevices", { controller: this }) }, _finishFindDevices: function () { if (this.garminPlugin.finishFindDevices()) { this.devices = Garmin.PluginUtils.parseDeviceXml(this.garminPlugin, this.getDetailedDeviceData); this.numDevices = this.devices.length; this.deviceNumber = 0; this._broadcaster.dispatch("onFinishFindDevices", { controller: this }) } else { setTimeout(function () { this._finishFindDevices() } .bind(this), 500) } }, setDeviceNumber: function (deviceNumber) { this.deviceNumber = deviceNumber }, getDeviceNumber: function () { return this.deviceNumber }, getDevices: function () { return this.devices }, getCurrentDeviceXml: function () { return this.garminPlugin.getDeviceDescriptionXml(this.deviceNumber) }, readDataFromDevice: function (fileType) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (!this._isAMember(fileType, [Garmin.DeviceControl.FILE_TYPES.gpx, Garmin.DeviceControl.FILE_TYPES.gpxDetail, Garmin.DeviceControl.FILE_TYPES.gpxDir, Garmin.DeviceControl.FILE_TYPES.tcx, Garmin.DeviceControl.FILE_TYPES.crs, Garmin.DeviceControl.FILE_TYPES.tcxDir, Garmin.DeviceControl.FILE_TYPES.crsDir, Garmin.DeviceControl.FILE_TYPES.wkt, Garmin.DeviceControl.FILE_TYPES.tcxProfile, Garmin.DeviceControl.FILE_TYPES.goals, Garmin.DeviceControl.FILE_TYPES.fit, Garmin.DeviceControl.FILE_TYPES.fitDir])) { var error = new Error(Garmin.DeviceControl.MESSAGES.invalidFileType + fileType); error.name = "InvalidTypeException"; throw error } if (!this.checkDeviceReadSupport(fileType)) { var error = new Error(Garmin.DeviceControl.MESSAGES.unsupportedReadDataType + fileType); error.name = "UnsupportedDataTypeException"; throw error } this.gpsDataType = fileType; this.gpsData = null; this.gpsDataString = null; this.idle = false; try { this._broadcaster.dispatch("onStartReadFromDevice", { controller: this }); switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpxDir: case Garmin.DeviceControl.FILE_TYPES.gpx: this.garminPlugin.startReadFromGps(this.deviceNumber); break; case Garmin.DeviceControl.FILE_TYPES.tcx: case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.goals: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: this.garminPlugin.startReadFitnessData(this.deviceNumber, this.gpsDataType); break; case Garmin.DeviceControl.FILE_TYPES.tcxDir: this.garminPlugin.startReadFitnessDirectory(this.deviceNumber, Garmin.DeviceControl.FILE_TYPES.tcx); break; case Garmin.DeviceControl.FILE_TYPES.crsDir: this.garminPlugin.startReadFitnessDirectory(this.deviceNumber, Garmin.DeviceControl.FILE_TYPES.crs); break; case Garmin.DeviceControl.FILE_TYPES.fitDir: this.garminPlugin.startReadFitDirectory(this.deviceNumber); break; case Garmin.DeviceControl.FILE_TYPES.deviceXml: this.gpsDataString = this.getCurrentDeviceXml(); break } this._progressRead() } catch (e) { this._reportException(e) } }, readDetailFromDevice: function (fileType, dataId) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (!this._isAMember(fileType, [Garmin.DeviceControl.FILE_TYPES.tcxDetail, Garmin.DeviceControl.FILE_TYPES.crsDetail])) { var error = new Error(Garmin.DeviceControl.MESSAGES.invalidFileType + fileType); error.name = "InvalidTypeException"; throw error } if (!this.checkDeviceReadSupport(fileType)) { throw new Error(Garmin.DeviceControl.MESSAGES.unsupportedReadDataType + fileType) } this.gpsDataType = fileType; this.gpsData = null; this.gpsDataString = null; this.idle = false; try { this._broadcaster.dispatch("onStartReadFromDevice", { controller: this }); switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.tcxDetail: this.garminPlugin.startReadFitnessDetail(this.deviceNumber, Garmin.DeviceControl.FILE_TYPES.tcx, dataId); break; case Garmin.DeviceControl.FILE_TYPES.crsDetail: this.garminPlugin.startReadFitnessDetail(this.deviceNumber, Garmin.DeviceControl.FILE_TYPES.crs, dataId); break } this._progressRead() } catch (e) { this._reportException(e) } }, readFromDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.gpx) }, readHistoryDetailFromFitnessDevice: function (historyId) { this.readDetailFromDevice(Garmin.DeviceControl.FILE_TYPES.tcx, historyId) }, readCourseDetailFromFitnessDevice: function (courseId) { this.readDetailFromDevice(Garmin.DeviceControl.FILE_TYPES.crs, courseId) }, readHistoryFromFitnessDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.tcx) }, readCoursesFromFitnessDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.crs) }, readWorkoutsFromFitnessDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.wkt) }, readUserProfileFromFitnessDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.tcxProfile) }, readGoalsFromFitnessDevice: function () { this.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.goals) }, getGpsData: function () { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (this.getReadCompletionState != Garmin.DeviceControl.FINISH_STATES.finished) { throw new Error(Garmin.DeviceControl.MESSAGES.incompleteRead) } return this.gpsData }, getGpsDataString: function () { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (this.getReadCompletionState != Garmin.DeviceControl.FINISH_STATES.finished) { throw new Error(Garmin.DeviceControl.MESSAGES.incompleteRead) } return this.gpsDataString }, getCompressedFitnessData: function () { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (this.getReadCompletionState != Garmin.DeviceControl.FINISH_STATES.finished) { throw new Error(Garmin.DeviceControl.MESSAGES.incompleteRead) } try { this.garminPlugin.getTcdXmlz() } catch (aException) { this._reportException(aException) } }, getReadCompletionState: function () { switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpxDir: case Garmin.DeviceControl.FILE_TYPES.gpxDetail: case Garmin.DeviceControl.FILE_TYPES.gpx: return this.garminPlugin.finishReadFromGps(); case Garmin.DeviceControl.FILE_TYPES.tcx: case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: case Garmin.DeviceControl.FILE_TYPES.goals: return this.garminPlugin.finishReadFitnessData(); case Garmin.DeviceControl.FILE_TYPES.tcxDir: case Garmin.DeviceControl.FILE_TYPES.crsDir: return this.garminPlugin.finishReadFitnessDirectory(); case Garmin.DeviceControl.FILE_TYPES.tcxDetail: case Garmin.DeviceControl.FILE_TYPES.crsDetail: return this.garminPlugin.finishReadFitnessDetail(); case Garmin.DeviceControl.FILE_TYPES.fitDir: return this.garminPlugin.finishReadFitDirectory() } }, _progressRead: function () { this._broadcaster.dispatch("onProgressReadFromDevice", { progress: this.getDeviceStatus(), controller: this }); setTimeout(function () { this._finishReadFromDevice() } .bind(this), 200) }, _finishReadFromDevice: function () { var completionState = this.getReadCompletionState(); try { if (completionState == Garmin.DeviceControl.FINISH_STATES.finished) { switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpxDir: case Garmin.DeviceControl.FILE_TYPES.gpxDetail: case Garmin.DeviceControl.FILE_TYPES.gpx: if (this.garminPlugin.gpsTransferSucceeded()) { this.gpsDataString = this.garminPlugin.getGpsXml(); this.gpsData = Garmin.XmlConverter.toDocument(this.gpsDataString); this._broadcaster.dispatch("onFinishReadFromDevice", { success: this.garminPlugin.gpsTransferSucceeded(), controller: this }) } break; case Garmin.DeviceControl.FILE_TYPES.tcx: case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.tcxDir: case Garmin.DeviceControl.FILE_TYPES.crsDir: case Garmin.DeviceControl.FILE_TYPES.tcxDetail: case Garmin.DeviceControl.FILE_TYPES.crsDetail: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: case Garmin.DeviceControl.FILE_TYPES.goals: if (this.garminPlugin.fitnessTransferSucceeded()) { this.gpsDataString = this.garminPlugin.getTcdXml(); this.gpsDataStringCompressed = this.garminPlugin.getTcdXmlz(); this.gpsData = Garmin.XmlConverter.toDocument(this.gpsDataString); this._broadcaster.dispatch("onFinishReadFromDevice", { success: this.garminPlugin.fitnessTransferSucceeded(), controller: this }) } break; case Garmin.DeviceControl.FILE_TYPES.fitDir: this.gpsDataString = this.garminPlugin.getDirectoryXml(); this.gpsData = Garmin.XmlConverter.toDocument(this.gpsDataString); this._broadcaster.dispatch("onFinishReadFromDevice", { success: this.garminPlugin.fitnessTransferSucceeded(), controller: this }); break } } else if (completionState == Garmin.DeviceControl.FINISH_STATES.messageWaiting) { var msg = this._messageWaiting(); this._broadcaster.dispatch("onWaitingReadFromDevice", { message: msg, controller: this }) } else { this._progressRead() } } catch (aException) { this._reportException(aException) } }, cancelReadFromDevice: function () { if (this.gpsDataType == Garmin.DeviceControl.FILE_TYPES.gpx) { this.garminPlugin.cancelReadFromGps() } else { this.garminPlugin.cancelReadFitnessData() } this._broadcaster.dispatch("onCancelReadFromDevice", { controller: this }) }, getBinaryFile: function (deviceNumber, relativeFilePath) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); if (relativeFilePath.capitalize().endsWith(".fit")) { this.gpsDataType = Garmin.DeviceControl.FILE_TYPES.fit } else { this.gpsDataType = Garmin.DeviceControl.FILE_TYPES.binary } var success; try { this.gpsDataString = this.garminPlugin.getBinaryFile(deviceNumber, relativeFilePath, false); this.gpsDataStringCompressed = this.garminPlugin.getBinaryFile(deviceNumber, relativeFilePath, true); success = true } catch (e) { success = false; this._reportException(e) } this._broadcaster.dispatch("onFinishReadFromDevice", { success: success, controller: this }); return this.gpsData }, writeAddressToDevice: function (address) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (!this.geocoder) { this.geocoder = new Garmin.Geocode(); this.geocoder.register(this) } this.geocoder.findLatLng(address) }, onException: function (json) { this._reportException(json.msg) }, onFinishedFindLatLon: function (json) { json.fileName = "address.gpx"; json.controller = this; this._broadcaster.dispatch("onFinishedFindLatLon", json); var factory = new Garmin.GpsDataFactory(); var gpxStr = factory.produceGpxString(null, [json.waypoint]); this.writeToDevice(gpxStr, json.fileName) }, writeDataToDevice: function (dataType, dataString, fileName) { if (!this.isUnlocked()) { throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked) } if (this.numDevices == 0) { throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected) } this.gpsDataType = dataType; if (!this.checkDeviceWriteSupport(this.gpsDataType)) { throw new Error(Garmin.DeviceControl.MESSAGES.unsupportedWriteDataType + this.gpsDataType) } try { this._broadcaster.dispatch("onStartWriteToDevice", { controller: this }); switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpx: this.garminPlugin.startWriteToGps(dataString, fileName, this.deviceNumber); break; case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.goals: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: case Garmin.DeviceControl.FILE_TYPES.nlf: this.garminPlugin.startWriteFitnessData(dataString, this.deviceNumber, fileName, this.gpsDataType); break; default: throw new Error(Garmin.DeviceControl.MESSAGES.unsupportedWriteDataType + this.gpsDataType) } this._progressWrite() } catch (e) { this._reportException(e) } }, writeToDevice: function (gpxString, fileName) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.gpx, gpxString, fileName) }, writeFitnessToDevice: function (tcxString, fileName) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.crs, tcxString, fileName) }, writeCoursesToFitnessDevice: function (tcxString, fileName) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.crs, tcxString, fileName) }, writeGoalsToFitnessDevice: function (tcxString) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.goals, tcxString, '') }, writeWorkoutsToFitnessDevice: function (tcxString, fileName) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.wkt, tcxString, fileName) }, writeUserProfileToFitnessDevice: function (tcxString, fileName) { this.writeDataToDevice(Garmin.DeviceControl.FILE_TYPES.tcxProfile, tcxString, fileName) }, downloadToDevice: function (xmlDownloadDescription) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); this.gpsDataType = Garmin.DeviceControl.FILE_TYPES.binary; try { this.garminPlugin.startDownloadData(xmlDownloadDescription, this.deviceNumber); this._progressWrite() } catch (e) { this._reportException(e) } }, _progressWrite: function () { this._broadcaster.dispatch("onProgressWriteToDevice", { progress: this.getDeviceStatus(), controller: this }); setTimeout(function () { this._finishWriteToDevice() } .bind(this), 200) }, _finishWriteToDevice: function () { try { var completionState; var success; switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpx: completionState = this.garminPlugin.finishWriteToGps(); success = this.garminPlugin.gpsTransferSucceeded(); break; case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.goals: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: case Garmin.DeviceControl.FILE_TYPES.nlf: completionState = this.garminPlugin.finishWriteFitnessData(); success = this.garminPlugin.fitnessTransferSucceeded(); break; case Garmin.DeviceControl.FILE_TYPES.gpi: case Garmin.DeviceControl.FILE_TYPES.fitCourse: case Garmin.DeviceControl.FILE_TYPES.fitSettings: case Garmin.DeviceControl.FILE_TYPES.fitSport: case Garmin.DeviceControl.FILE_TYPES.binary: completionState = this.garminPlugin.finishDownloadData(); success = this.garminPlugin.downloadDataSucceeded(); break; case Garmin.DeviceControl.FILE_TYPES.firmware: completionState = this.garminPlugin.finishUnitSoftwareUpdate(); success = this.garminPlugin.downloadDataSucceeded(); break; default: throw new Error(Garmin.DeviceControl.MESSAGES.unsupportedWriteDataType + this.gpsDataType) } if (completionState == Garmin.DeviceControl.FINISH_STATES.finished) { this._broadcaster.dispatch("onFinishWriteToDevice", { success: success, controller: this }) } else if (completionState == Garmin.DeviceControl.FINISH_STATES.messageWaiting) { var msg = this._messageWaiting(); this._broadcaster.dispatch("onWaitingWriteToDevice", { message: msg, controller: this }) } else { this._progressWrite() } } catch (aException) { this._reportException(aException) } }, cancelWriteToDevice: function () { switch (this.gpsDataType) { case Garmin.DeviceControl.FILE_TYPES.gpx: this.garminPlugin.cancelWriteToGps(); break; case Garmin.DeviceControl.FILE_TYPES.gpi: case Garmin.DeviceControl.FILE_TYPES.binary: this.garminPlugin.cancelDownloadData(); break; case Garmin.DeviceControl.FILE_TYPES.firmware: this.garminPlugin.cancelUnitSoftwareUpdate(); break; case Garmin.DeviceControl.FILE_TYPES.crs: case Garmin.DeviceControl.FILE_TYPES.goals: case Garmin.DeviceControl.FILE_TYPES.wkt: case Garmin.DeviceControl.FILE_TYPES.tcxProfile: case Garmin.DeviceControl.FILE_TYPES.nlf: this.garminPlugin.cancelWriteFitnessData(); break } this._broadcaster.dispatch("onCancelWriteToDevice", { controller: this }) }, bytesAvailable: function (relativeFilePath) { return this.garminPlugin.bytesAvailable(this.getDeviceNumber(), relativeFilePath) }, downloadFirmwareToDevice: function (updateResponsesXml) { if (!this.isUnlocked()) throw new Error(Garmin.DeviceControl.MESSAGES.pluginNotUnlocked); if (this.numDevices == 0) throw new Error(Garmin.DeviceControl.MESSAGES.noDevicesConnected); this.gpsDataType = Garmin.DeviceControl.FILE_TYPES.firmware; try { this.garminPlugin.startUnitSoftwareUpdate(updateResponsesXml, this.deviceNumber); this._progressWrite() } catch (e) { this._reportException(e) } }, unlock: function (pathKeyPairsArray) { this.pluginUnlocked = this.garminPlugin.unlock(pathKeyPairsArray); return this.pluginUnlocked }, register: function (listener) { this._broadcaster.register(listener) }, isUnlocked: function () { return this.pluginUnlocked }, respondToMessageBox: function (response) { this.garminPlugin.respondToMessageBox(response ? 1 : 2); this._progressWrite() }, _messageWaiting: function () { var messageDoc = Garmin.XmlConverter.toDocument(this.garminPlugin.getMessageBoxXml()); var text = messageDoc.getElementsByTagName("Text")[0].childNodes[0].nodeValue; var message = new Garmin.MessageBox("Question", text); var buttonNodes = messageDoc.getElementsByTagName("Button"); for (var i = 0; i < buttonNodes.length; i++) { var caption = buttonNodes[i].getAttribute("Caption"); var value = buttonNodes[i].getAttribute("Value"); message.addButton(caption, value) } return message }, getDeviceStatus: function () { var aProgressXml = this.garminPlugin.getProgressXml(); var theProgressDoc = Garmin.XmlConverter.toDocument(aProgressXml); var title = ""; if (theProgressDoc.getElementsByTagName("Title").length > 0) { title = theProgressDoc.getElementsByTagName("Title")[0].childNodes[0].nodeValue } var progress = new Garmin.TransferProgress(title); var textNodes = theProgressDoc.getElementsByTagName("Text"); for (var i = 0; i < textNodes.length; i++) { if (textNodes[i].childNodes.length > 0) { var text = textNodes[i].childNodes[0].nodeValue; if (text != "") progress.addText(text) } } var percentageNode = theProgressDoc.getElementsByTagName("ProgressBar")[0]; if (percentageNode != undefined) { if (percentageNode.getAttribute("Type") == "Percentage") { progress.setPercentage(percentageNode.getAttribute("Value")) } else if (percentageNode.getAttribute("Type") == "Indefinite") { progress.setPercentage(100) } } return progress }, _isAMember: function (element, array) { return array.any(function (str) { return str == element }) }, getPluginVersion: function () { return this.garminPlugin.getPluginVersion() }, getPluginVersionString: function () { return this.garminPlugin.getPluginVersionString() }, setPluginRequiredVersion: function (reqVersionArray) { if (reqVersionArray != null) { this.garminPlugin.setPluginRequiredVersion(reqVersionArray) } }, setPluginLatestVersion: function (reqVersionArray) { if (reqVersionArray != null) { this.garminPlugin.setPluginLatestVersion(reqVersionArray) } }, isPluginInitialized: function () { return (this.garminPlugin != null) }, isPluginInstalled: function () { return (this.garminPlugin.getVersionXml() != undefined) }, _reportException: function (exception) { this._broadcaster.dispatch("onException", { msg: exception, controller: this }) }, getDevicesCount: function () { return this.numDevices }, checkDeviceReadSupport: function (datatype) { if (datatype == Garmin.DeviceControl.FILE_TYPES.fitDir) { if (this.garminPlugin.getSupportsFitDirectoryRead() == false) { return false } } var isDatatypeSupported; var device = this._getDeviceByNumber(this.deviceNumber); var baseDatatype; switch (datatype) { case Garmin.DeviceControl.FILE_TYPES.gpxDir: case Garmin.DeviceControl.FILE_TYPES.gpxDetail: baseDatatype = Garmin.DeviceControl.FILE_TYPES.gpx; break; case Garmin.DeviceControl.FILE_TYPES.tcxDir: case Garmin.DeviceControl.FILE_TYPES.tcxDetail: baseDatatype = Garmin.DeviceControl.FILE_TYPES.tcx; break; case Garmin.DeviceControl.FILE_TYPES.crsDir: case Garmin.DeviceControl.FILE_TYPES.crsDetail: baseDatatype = Garmin.DeviceControl.FILE_TYPES.crs; break; case Garmin.DeviceControl.FILE_TYPES.fitDir: case Garmin.DeviceControl.FILE_TYPES.fitFile: baseDatatype = Garmin.DeviceControl.FILE_TYPES.fit; break; default: baseDatatype = datatype } if (baseDatatype == Garmin.DeviceControl.FILE_TYPES.deviceXml || baseDatatype == Garmin.DeviceControl.FILE_TYPES.firmware) { isDatatypeSupported = true } else { isDatatypeSupported = device.supportDeviceDataTypeRead(baseDatatype) } return isDatatypeSupported }, checkDeviceWriteSupport: function (datatype) { var isDatatypeSupported = false; var device = this._getDeviceByNumber(this.deviceNumber); if (datatype == Garmin.DeviceControl.FILE_TYPES.binary || datatype == Garmin.DeviceControl.FILE_TYPES.gpi) { isDatatypeSupported = true } else { isDatatypeSupported = device.supportDeviceDataTypeWrite(datatype) } return isDatatypeSupported }, _getDeviceByNumber: function (deviceNum) { for (var index = 0; index < this.devices.length; index++) { if (this.devices[index].getNumber() == deviceNum) { return this.devices[index] } } }, toString: function () { return "Garmin Javascript GPS Controller managing " + this.numDevices + " device(s)" } }; var BrowserSupport = { isBrowserSupported: function () { return ((BrowserDetect.OS == "Windows" && (BrowserDetect.browser == "Firefox" || BrowserDetect.browser == "Mozilla" || BrowserDetect.browser == "Explorer" || BrowserDetect.browser == "Safari")) || (BrowserDetect.OS == "Mac" && (BrowserDetect.browser == "Firefox" || BrowserDetect.browser == "Safari"))) } }; Garmin.DeviceControl.MESSAGES = { deviceControlMissing: "Garmin.DeviceControl depends on the Garmin.DevicePlugin framework.", missingPluginTag: "Plug-In HTML tag not found.", browserNotSupported: "Your browser is not supported to use the Garmin Communicator Plug-In.", pluginNotInstalled: "Garmin Communicator Plugin NOT detected.", outOfDatePlugin1: "Your version of the Garmin Communicator Plug-In is out of date.<br/>Required: ", outOfDatePlugin2: "Current: ", updatePlugin1: "Your version of the Garmin Communicator Plug-In is not the latest version. Latest version: ", updatePlugin2: ", current: ", pluginNotUnlocked: "Garmin Plugin has not been unlocked", noDevicesConnected: "No device connected, can't communicate with device.", invalidFileType: "Cannot process the device file type: ", incompleteRead: "Incomplete read, cannot get compressed format.", unsupportedReadDataType: "Your device does not support reading of the type: ", unsupportedWriteDataType: "Your device does not support writing of the type: " }; Garmin.DeviceControl.FINISH_STATES = { idle: 0, working: 1, messageWaiting: 2, finished: 3 }; Garmin.DeviceControl.FILE_TYPES = { gpx: "GPSData", tcx: "FitnessHistory", gpi: "gpi", crs: "FitnessCourses", wkt: "FitnessWorkouts", goals: "FitnessActivityGoals", tcxProfile: "FitnessUserProfile", binary: "BinaryData", voices: "Voices", nlf: "FitnessNewLeaf", fit: "FITBinary", fitCourse: "FIT_TYPE_6", fitSettings: "FIT_TYPE_2", fitSport: "FIT_TYPE_3", tcxDir: "FitnessHistoryDirectory", crsDir: "FitnessCoursesDirectory", gpxDir: "GPSDataDirectory", tcxDetail: "FitnessHistoryDetail", crsDetail: "FitnessCoursesDetail", gpxDetail: "GPSDataDetail", deviceXml: "DeviceXml", fitDir: "FitDirectory", fitFile: "FitFile", firmware: "Firmware" }; Garmin.DeviceControl.TRANSFER_DIRECTIONS = { read: "OutputFromUnit", write: "InputToUnit", both: "InputOutput" }; Garmin.TransferProgress = Class.create(); Garmin.TransferProgress.prototype = { initialize: function (title) { this.title = title; this.text = new Array(); this.percentage = null }, addText: function (textString) { this.text.push(textString) }, getText: function () { return this.text }, getTitle: function () { return this.title }, setPercentage: function (percentage) { this.percentage = percentage }, getPercentage: function () { return this.percentage }, toString: function () { var progressString = ""; if (this.getTitle() != null) { progressString += this.getTitle() } if (this.getPercentage() != null) { progressString += ": " + this.getPercentage() + "%" } return progressString } }; Garmin.MessageBox = Class.create(); Garmin.MessageBox.prototype = { initialize: function (type, text) { this.type = type; this.text = text; this.buttons = new Array() }, getType: function () { return this.type }, getText: function () { return this.text }, addButton: function (caption, value) { this.buttons.push({ caption: caption, value: value }) }, getButtons: function () { return this.buttons }, getButtonValue: function (caption) { for (var i = 0; i < this.buttons.length; i++) { if (this.buttons[i].caption == caption) { return this.buttons[i].value } } return null }, toString: function () { return this.getText() } };

var DeviceHandler = Class.create({

    deviceDisplayName: null,

    initialize: function (deviceUI, readDataFromDeviceCallback, readDetailFromDeviceCallback) {
        this.readDataFromDevice = readDataFromDeviceCallback;
        this.readDetailFromDevice = readDetailFromDeviceCallback;
        this.deviceUI = deviceUI;
    },

    onStartFindDevices: function (json) { this.deviceUI.showGarminSyncing(); },

    onCancelFindDevices: function (json) {
        this.deviceUI.hideGarminDeviceSelector();
    },

    onFinishFindDevices: function (json) {

        var rawDevices = json.controller.getDevices(),
				devices = [];
        for (var i = 0, length = rawDevices.length; i < length; i++) {
            var device = rawDevices[i];

            if (device.supportDeviceDataTypeRead(Garmin.DeviceControl.FILE_TYPES.tcx)) {
                devices.push(device);
            }
        }

        if (devices.length > 0) {
            if (devices.length == 1) {
                this.readingDirectory = true;
                this.readDataFromDevice(device.getNumber());

            } else { // user has to select device to import from
                this.deviceUI.clearGarminDeviceSelectorElements();

                for (var i = 0, length = devices.length; i < length; i++) {
                    var device = devices[i];

                    var elt = new Element('a', { href: '#', className: 'block garmin_device' }).update(device.getDisplayName());
                    var readDataF = function (n) {
                        return function () {
                            this.readDataFromDevice(n);
                            this.deviceUI.hideGarminDeviceSelector();
                        } .bind(this);
                    } .bind(this);
                    elt.observe('click', readDataF(device.getNumber()));

                    this.deviceUI.addGarminDeviceSelectorElement(elt);
                }
            }
        } else {
            this.deviceUI.showError("We couldn't find any connected devices to sync with.");
        }
    },

    // called both on start reading dir and detail
    onStartReadFromDevice: function (json) {
        if (this.readingDirectory) {
            this.deviceUI.showGarminSyncing();
        }
    },

    onProgressReadFromDevice: function (json) {
        if (this.readingDirectory) {
            var progress = json.progress, // Garmin.TransferProgress
  				controller = json.controller;

            // device status will be 'Transfer Complete' if it's done
            try {
                var percent = progress.getPercentage() || controller.getDeviceStatus();
                if (percent == 'Transfer Complete') {
                    percent = 100;
                }
                percent = (percent / 2).round();

                this.deviceUI.updateGarminProgress(percent);
            } catch (err) { }
        }
    },

    onCancelReadFromDevice: function (json) {
        this.deviceUI.hideSyncing();
    },

    onFinishReadFromDevice: function (json) {
        this.readingDirectory = false;
        var success = json.success,
				controller = json.controller,
				fileType = json.controller.gpsDataType;

        if (success) {
            switch (fileType) {
                case Garmin.DeviceControl.FILE_TYPES.tcxDir:
                case Garmin.DeviceControl.FILE_TYPES.tcxDetail:
                    try {
                        this._uploadTCX(fileType, controller.gpsDataStringCompressed);
                    } catch (err) {
                        alert('Error processing TCX directory on device.');
                    }
                    break;
                default:
                    alert('Cannot read file type: ' + fileType);
                    break;
            }
        } else {
            this.deviceUI.showError('Problem reading from your device, please try again.');
        }
    },

    _importNext: function () {
        var activityId = this.pendingImports.pop();
        if (activityId) {
            // console.log('reading from device: ' + activityId);
            this.readDetailFromDevice(activityId);
        }
    },

    _uploadTCX: function (fileType, gpsDataStringCompressed) {
        var uploadURL, callback;
        if (fileType == Garmin.DeviceControl.FILE_TYPES.tcxDir) {
            // uploadURL = '/account/workouts/imports/garmin_tcx_directory.json';
            uploadURL = 'http://flexfwd.com/DesktopModules/ATI_Base/services/json/garmin.aspx';
            callback = function (transport) {
                var activityIds = transport.responseJSON;

                if (activityIds && activityIds.length > 0) {
                    this.deviceUI.updateGarminProgress(51);

                    // console.log('importing ' + activityIds.length + ' activites')
                    this.importsCount = activityIds.length;
                    this.pendingImports = activityIds;

                    this._importNext(); // start the first import
                } else {
                    this.deviceUI.showNotice('No new activities found on the device.');
                }
            }
        } else if (fileType == Garmin.DeviceControl.FILE_TYPES.tcxDetail) {
            var hasNext = this.pendingImports.length > 0;

            uploadURL = 'http://flexfwd.com/DesktopModules/ATI_Base/services/json/garmin.aspx'
            if (!hasNext) {
                uploadURL += '?finished=true';
            }
            callback = function (transport) {
                try {
                    var i = this.importsCount - this.pendingImports.length;
                    var percent = (i / this.importsCount) * 100;
                    percent = (percent / 2).round();

                    this.deviceUI.updateGarminProgress(percent + 50); // TODO: should be 25% for reading off device, not 50!
                } catch (err) { }

                if (hasNext) {
                    this._importNext(); // start the next import
                }
            }
        }
        //2011-01-03T00:55:08Z
        /*
        alert(gpsDataStringCompressed);
        var activityId = '2011-01-03T00:55:08Z';
        if (activityId) {
            // console.log('reading from device: ' + activityId);
            this.readDetailFromDevice(activityId);
        }
        */
        new Ajax.Request(uploadURL, {
        parameters: {
        gps_data: gpsDataStringCompressed,
        authenticity_token: window._token,
        fileType: fileType 
        },
        onSuccess: callback.bind(this),
        onFailure: function (transport) { alert('Problem uploading data to server. Error: ' + transport.status + ' ' + transport.statusText); }
        });
        
    }

});

var GarminControl = Class.create({

    deviceDisplayName: null,

    initialize: function (deviceUI, options) {
        this.deviceUI = deviceUI;

        this.debug = true; // TODO: make this an option
        this.routeEnabled = options.parse_route;

        if (!options.test) {
            try {
                this.controller = new Garmin.DeviceControl();
            } catch (err) {
                if (err.name == "BrowserNotSupportedException") {
                    this.deviceUI.browserNotSupported();
                } else if (err.name == "PluginNotInstalledException") {
                    this.deviceUI.pluginNotInstalled();
                } else {
                    this.deviceUI.showError(err);
                }
                return;
            }

            this.deviceUI.garminSyncLink.observe('click', this._findAndReadDevices.bindAsEventListener(this));

            this.controller.register(new DeviceHandler(this.deviceUI,
                                                        this._readDataFromDevice.bind(this),
			                                            this._readDetailFromDevice.bind(this)));
            this.controller.unlock([options.url, options.key]);
        }

        this.lastActivityTimestamp = options.timestamp;
    },

    sync: function () {
        this._findAndReadDevices();
    },

    _findAndReadDevices: function () {
        if (this.controller) { // !this.isImporting
            this.controller.findDevices();
        }
    },

    _readDetailFromDevice: function (fileId) {
        try {
            this.controller.readDetailFromDevice(Garmin.DeviceControl.FILE_TYPES.tcxDetail, fileId);
        } catch (err) { alert('Error reading from device: ' + err); }
    },

    // NOTE: passed as a callback to device handler
    _readDataFromDevice: function (n) {
        try {
            this.controller.setDeviceNumber(n);
            this.deviceDisplayName = this.controller.devices[n].getDisplayName();

            if (this.controller.checkDeviceReadSupport(Garmin.DeviceControl.FILE_TYPES.tcx)) {
                // this.controller.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.tcx); // Garmin.DeviceControl.FILE_TYPES.gpx
                this.controller.readDataFromDevice(Garmin.DeviceControl.FILE_TYPES.tcxDir);
            } else {
                this.deviceUI.showError(this.deviceDisplayName + ' doesn\'t support TCX. Try <a href="http://www.garmin.com/products/communicator/">upgrading</a> your plugin.');
            }
        } catch (err) { alert('Error reading from device: ' + err); }
    },

    _recordError: function (msg, err, dontMarkAsFailed) {
        if (!dontMarkAsFailed) {
            this.failed = true;
        }

        new Ajax.Request('/account/services/garmin/sync_error.js', {
            parameters: {
                message: msg,
                error: err.toString(),
                authenticity_token: window._token
            }
        });

        if (this.debug) {
            alert(msg + ': ' + err);
        }
    }

});
